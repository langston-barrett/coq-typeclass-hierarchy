<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>TypeclassHierarchy.Interfaces.Functor</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library TypeclassHierarchy.Interfaces.Functor</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Program.Basics.html#"><span class="id" title="library">Coq.Program.Basics</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">MathClasses.interfaces.canonical_names</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="TypeclassHierarchy.Util.FunctionSetoid.html#"><span class="id" title="library">TypeclassHierarchy.Util.FunctionSetoid</span></a>.<br/>

<br/>
<span class="id" title="keyword">Infix</span> <a name="1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">&quot;</span></a>=" := <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="3f5a44c19dec363542c001f931c92296"><span class="id" title="notation">&quot;</span></a>(=)" := <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">mc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="8d09773dc0910eda0d98732cbf89246d"><span class="id" title="notation">&quot;</span></a>( x =)" := (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> <span class="id" title="var">x</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">mc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="84f1ddf3f459dda30beeeddb918518b3"><span class="id" title="notation">&quot;</span></a>(= x )" := (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Unicode.Utf8_core.html#e347aba07034a66189f14f85f0430e87"><span class="id" title="notation">λ</span></a> <span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Unicode.Utf8_core.html#e347aba07034a66189f14f85f0430e87"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="var">x</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">mc_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 A functor contains data in such a way that a function can be applied uniformly
 across the contained objects.

<div class="paragraph"> </div>

 The functor follows three (classical) laws:
<ul class="doclist">
<li> fmap id = id

</li>
<li> fmap (g ∘ h) = (fmap g) ∘ (fmap h)

</li>
</ul>

<div class="paragraph"> </div>

 We additionally require that fmap is proper with respect to the equivalence
 relation on functions, i.e. if f and g are extensionally equal, fmap f and
 fmap g are as well.

<div class="paragraph"> </div>

 A lot of the notation (e.g. setoid/extensional equality) is desugared here,
 because Coq has trouble inferring the types.

<div class="paragraph"> </div>

 We use Type rather than Set, as Functors must live in Set+1, and we want to be able to compose Functors.
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <a name="Functor"><span class="id" title="record">Functor</span></a> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;{ <a name="fmap"><span class="id" title="projection">fmap</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span>}, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Y"><span class="id" title="variable">Y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Y"><span class="id" title="variable">Y</span></a><br/>
&nbsp;&nbsp;; <a name="fmap_proper"><span class="id" title="projection">fmap_proper</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#Proper"><span class="id" title="class">Proper</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#5bcff5fca4c3a87e683dd8ca07bab63f"><span class="id" title="notation">(</span></a>@<a class="idref" href="TypeclassHierarchy.Util.FunctionSetoid.html#extensional_equality"><span class="id" title="definition">extensional_equality</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#5bcff5fca4c3a87e683dd8ca07bab63f"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#5bcff5fca4c3a87e683dd8ca07bab63f"><span class="id" title="notation">==&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#5bcff5fca4c3a87e683dd8ca07bab63f"><span class="id" title="notation">(</span></a>@<a class="idref" href="TypeclassHierarchy.Util.FunctionSetoid.html#extensional_equality"><span class="id" title="definition">extensional_equality</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Classes.Morphisms.html#5bcff5fca4c3a87e683dd8ca07bab63f"><span class="id" title="notation">)</span></a>) (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>)<br/>
&nbsp;&nbsp;; <a name="fmap_identity"><span class="id" title="projection">fmap_identity</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, @<a class="idref" href="TypeclassHierarchy.Util.FunctionSetoid.html#extensional_equality"><span class="id" title="definition">extensional_equality</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <span class="id" title="definition">id</span>) <span class="id" title="definition">id</span><br/>
&nbsp;&nbsp;; <a name="fmap_composition"><span class="id" title="projection">fmap_composition</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>: <span class="id" title="keyword">Type</span>} (<span class="id" title="var">h</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="TypeclassHierarchy.Util.FunctionSetoid.html#extensional_equality"><span class="id" title="definition">extensional_equality</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a>) (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Program.Basics.html#23b053569700a43fa034e3971fb6ded6"><span class="id" title="notation">∘</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#h"><span class="id" title="variable">h</span></a>)) (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Program.Basics.html#23b053569700a43fa034e3971fb6ded6"><span class="id" title="notation">∘</span></a> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#h"><span class="id" title="variable">h</span></a>)<br/>
&nbsp;&nbsp;}.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> {<span class="id" title="var">F</span>} {<span class="id" title="var">Functor</span>} {<span class="id" title="var">X</span>} {<span class="id" title="var">Y</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
 An apply is a halfway point between functor and applicative/bind. It's not very
 useful in and of itself, but exists to unify the notation between binds and
 applicatives.

<div class="paragraph"> </div>

 In addition to the functor laws, an apply follows one more:
<ul class="doclist">
<li> ap g (ap f a) = ap (ap (fmap (∘) g) f) a

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <a name="Apply"><span class="id" title="record">Apply</span></a> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;{ <a name="apply_functor"><span class="id" title="projection">apply_functor</span></a> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Functor"><span class="id" title="class">Functor</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a><br/>
&nbsp;&nbsp;; <a name="ap"><span class="id" title="projection">ap</span></a>   : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;; <a name="apply_composition"><span class="id" title="projection">apply_composition</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>)) (<span class="id" title="var">g</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a>)) (<span class="id" title="var">a</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#fmap"><span class="id" title="method">fmap</span></a> <span class="id" title="notation">(∘)</span> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
 An applicative is a functor that also allows for both applying functions inside
 the functor to arguments inside the functor, and embedding arbitrary objects in
 the functor.

<div class="paragraph"> </div>

 In addition to the apply laws, an applicative follows three others:
<ul class="doclist">
<li> ap (pure id) v = v

</li>
<li> ap (pure f) (pure x) = pure (f x)

</li>
<li> ap u (pure y) = ap (pure (fun f =&gt; f y)) u

</li>
<li> ap u (ap v w) = ap (pure (∘)) (ap u (ap v w))

</li>
</ul>

<div class="paragraph"> </div>

 As always, lot of the notation (e.g. setoid/extensional equality) is desugared
 to reduce the need for (slow and somewhat unreliable) type inference.

<div class="paragraph"> </div>

 In particular, we often have the following let clause:
 "app := @ap F applicative_apply" which specializes the "ap" method to the
 current functor. If this is confusing, just think of "app" as "ap".
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <a name="Applicative"><span class="id" title="record">Applicative</span></a> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;{ <a name="applicative_apply"><span class="id" title="projection">applicative_apply</span></a> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Apply"><span class="id" title="class">Apply</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a><br/>
&nbsp;&nbsp;; <a name="pure"><span class="id" title="projection">pure</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>}, <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;; <a name="ap_identity"><span class="id" title="projection">ap_identity</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#applicative_apply"><span class="id" title="method">applicative_apply</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) <span class="id" title="definition">id</span>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;; <a name="ap_homomorphism"><span class="id" title="projection">ap_homomorphism</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">a</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">app</span> := @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#applicative_apply"><span class="id" title="method">applicative_apply</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">in</span> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a>) (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>)<br/>
&nbsp;&nbsp;; <a name="ap_interchange"><span class="id" title="projection">ap_interchange</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>)) (<span class="id" title="var">a</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">app</span> := @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#applicative_apply"><span class="id" title="method">applicative_apply</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">in</span> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> ⇒ <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>)) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a><br/>
&nbsp;&nbsp;; <a name="ap_composition"><span class="id" title="projection">ap_composition</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>)) (<span class="id" title="var">g</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a>)) (<span class="id" title="var">a</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">app</span> := @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#applicative_apply"><span class="id" title="method">applicative_apply</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">in</span> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#app"><span class="id" title="variable">app</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#ap"><span class="id" title="method">ap</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <span class="id" title="notation">(∘)</span>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
 A bind is an apply with an additional operation that takes the output of
 one computation and feeds it into the next, composing the two in a chain.

<div class="paragraph"> </div>

 In addition to the apply laws, binds must follow one other:
<ul class="doclist">
<li> bind (bind x f) g = bind x (fun y =&gt; bind (f y) g)

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="keyword">Bind</span> (<span class="id" title="var">F</span> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;{ <a name="bind_apply"><span class="id" title="projection">bind_apply</span></a> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Apply"><span class="id" title="class">Apply</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a><br/>
&nbsp;&nbsp;; <a name="bind"><span class="id" title="projection">bind</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>}, <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;; <a name="bind_associative"><span class="id" title="projection">bind_associative</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#F"><span class="id" title="variable">F</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> (@<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ @<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#C"><span class="id" title="variable">C</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#g"><span class="id" title="variable">g</span></a>)<br/>
&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
 A monad is a lot of things, but really just an applicative and a bind together.
 It supports chaining of functions, and embedding of objects into the type
 constructor.

<div class="paragraph"> </div>

 In addition to the laws provided by apply and bind, it has identities:
<ul class="doclist">
<li> bind (pure x) f = f x

</li>
<li> bind x pure = x

</li>
</ul>
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Class</span> <a name="Monad"><span class="id" title="record">Monad</span></a> (<span class="id" title="var">M</span> : <span class="id" title="keyword">Type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;{ <a name="monad_applicative"><span class="id" title="projection">monad_applicative</span></a> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#Applicative"><span class="id" title="class">Applicative</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#M"><span class="id" title="variable">M</span></a><br/>
&nbsp;&nbsp;; <a name="monad_bind"><span class="id" title="projection">monad_bind</span></a>     : <span class="id" title="keyword">Bind</span> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#M"><span class="id" title="variable">M</span></a><br/>
&nbsp;&nbsp;; <a name="monad_id_left"><span class="id" title="projection">monad_id_left</span></a>  : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#M"><span class="id" title="variable">M</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> (<a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;; <a name="monad_id_right"><span class="id" title="projection">monad_id_right</span></a> : <span class="id" title="keyword">∀</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5pl3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#M"><span class="id" title="variable">M</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#M"><span class="id" title="variable">M</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#A"><span class="id" title="variable">A</span></a>), <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#bind"><span class="id" title="method">bind</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#pure"><span class="id" title="method">pure</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="TypeclassHierarchy.Interfaces.Functor.html#x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;}.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>